* SPCHT
    [x] Interpreter for mapping reference via mapping_setting
    [x] handling of $default entries in mapping_setting instead of mapping
    [ ] make regex matching for mappings work
     #  probably to be realized in spcht_node_mapping()
    [x] $inherit parameter actually inherting the value in $default
    [ ] json error insights on load of file
    [ ] possible performance bottlenecks
    [ ] Filter Value for x
    [ ] Remove Parts of the value string
    [ ] Remove duplicated information # should not really matter but still
* SPARQL
    [ ] differenciate between graph and string that happens to be a link to somewhere
    [ ] generation of valid sparql queries
    [ ] shortening of queries with @prefix
    [ ] SPAQRL Escaping
* EXPORT
    [ ] export data directly to a .ttl file
* IMPORT
    [ ] you dont need to technically request *, just all the things you need, that might be less



def spcht_recursion_node(sub_dict, raw_dict, marc21_dict=None):
    # i do not like the general use of recursion, but for traversing trees this seems the best solution
    # there is actually not so much overhead in python, its more one of those stupid feelings, i googled some
    # random reddit thread: https://old.reddit.com/r/Python/comments/4hkds8/do_you_recommend_using_recursion_in_python_why_or/
    # @param sub_dict = the part of the descriptor dictionary that is in ['fallback']
    # @param raw_dict = the big raw dictionary that we are working with
    # @param marc21_dict = an alternative marc21 dictionary, already cooked and ready
    # the header/id field is special in some sense, therefore there is a separated function for it
    # ! this can return anything, string, list, dictionary, it just takes the content, careful
    print(colored(sub_dict.get('name', ""), "blue"), end=" ")
    if sub_dict['source'] == "marc":
        if marc21_dict is None:
            print(colored("No Marc", "yellow"), end="|")
            pass
        else:
            print(colored("some Marc", "yellow"), end="-> ")
            if is_dictkey(marc21_dict, sub_dict['field'].lstrip("0")):
                if sub_dict['subfield'] == 'none':
                    return marc21_dict[sub_dict['field']]
                elif is_dictkey(marc21_dict[sub_dict['field'].lstrip("0")], sub_dict['subfield']):
                    return marc21_dict[sub_dict['field'].lstrip("0")][sub_dict['subfield']]
        # ! this handling of the marc format is probably too simply
        # TODO: gather more samples of awful marc and process it
    elif sub_dict['source'] == "dict":
        print(colored("Source Dict", "yellow"), end="-> ")
        if is_dictkey(raw_dict, sub_dict['field']):  # main field name
            return spcht_node_mapping(raw_dict[sub_dict['field']], sub_dict.get('mapping'), sub_dict.get('mapping_settings'))
        # ? since i prime the sub_dict what is even the point for checking the existence of the key, its always there
        elif is_dictkey(sub_dict, 'alternatives') and sub_dict['alternatives'] is not None:  # traverse list of alternative field names
            print(colored("Alternatives", "yellow"), end="-> ")
            for entry in sub_dict['alternatives']:
                if is_dictkey(raw_dict, entry):
                    return spcht_node_mapping(raw_dict[entry], sub_dict.get('mapping'), sub_dict.get('mapping_settings'))

    if is_dictkey(sub_dict, 'fallback') and sub_dict['fallback'] is not None:  # we only get here if everything else failed
        # * this is it, the dreaded recursion, this might happen a lot of times, depending on how motivated the
        # * librarian was who wrote the descriptor format
        print(colored("Fallback triggered", "yellow"), sub_dict.get('fallback'), end="-> ")
        return spcht_recursion_node(sub_dict['fallback'], raw_dict, marc21_dict)
    else:
        print(colored("absolutlty nothing", "yellow"), end=" | ")
        return None  # usually i return false in these situations, but none seems appropriate
# TODO: remove debug prints